// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: gtfs-realtime_1007_extension.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum TransitRealtime_TrackDirection: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case up // = 0
  case down // = 1

  init() {
    self = .up
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .up
    case 1: self = .down
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .up: return 0
    case .down: return 1
    }
  }

}

struct TransitRealtime_FeedMessage: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var header: TransitRealtime_FeedHeader {
    get {return _header ?? TransitRealtime_FeedHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  var entity: [TransitRealtime_FeedEntity] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _header: TransitRealtime_FeedHeader? = nil
}

struct TransitRealtime_FeedHeader: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gtfsRealtimeVersion: String {
    get {return _gtfsRealtimeVersion ?? String()}
    set {_gtfsRealtimeVersion = newValue}
  }
  /// Returns true if `gtfsRealtimeVersion` has been explicitly set.
  var hasGtfsRealtimeVersion: Bool {return self._gtfsRealtimeVersion != nil}
  /// Clears the value of `gtfsRealtimeVersion`. Subsequent reads from it will return its default value.
  mutating func clearGtfsRealtimeVersion() {self._gtfsRealtimeVersion = nil}

  var incrementality: TransitRealtime_FeedHeader.Incrementality {
    get {return _incrementality ?? .fullDataset}
    set {_incrementality = newValue}
  }
  /// Returns true if `incrementality` has been explicitly set.
  var hasIncrementality: Bool {return self._incrementality != nil}
  /// Clears the value of `incrementality`. Subsequent reads from it will return its default value.
  mutating func clearIncrementality() {self._incrementality = nil}

  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Incrementality: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case fullDataset // = 0
    case differential // = 1

    init() {
      self = .fullDataset
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .fullDataset
      case 1: self = .differential
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .fullDataset: return 0
      case .differential: return 1
      }
    }

  }

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _gtfsRealtimeVersion: String? = nil
  fileprivate var _incrementality: TransitRealtime_FeedHeader.Incrementality? = nil
  fileprivate var _timestamp: UInt64? = nil
}

struct TransitRealtime_FeedEntity: SwiftProtobuf.ExtensibleMessage, @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id ?? String()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {_uniqueStorage()._id = nil}

  var isDeleted: Bool {
    get {return _storage._isDeleted ?? false}
    set {_uniqueStorage()._isDeleted = newValue}
  }
  /// Returns true if `isDeleted` has been explicitly set.
  var hasIsDeleted: Bool {return _storage._isDeleted != nil}
  /// Clears the value of `isDeleted`. Subsequent reads from it will return its default value.
  mutating func clearIsDeleted() {_uniqueStorage()._isDeleted = nil}

  var tripUpdate: TransitRealtime_TripUpdate {
    get {return _storage._tripUpdate ?? TransitRealtime_TripUpdate()}
    set {_uniqueStorage()._tripUpdate = newValue}
  }
  /// Returns true if `tripUpdate` has been explicitly set.
  var hasTripUpdate: Bool {return _storage._tripUpdate != nil}
  /// Clears the value of `tripUpdate`. Subsequent reads from it will return its default value.
  mutating func clearTripUpdate() {_uniqueStorage()._tripUpdate = nil}

  var vehicle: TransitRealtime_VehiclePosition {
    get {return _storage._vehicle ?? TransitRealtime_VehiclePosition()}
    set {_uniqueStorage()._vehicle = newValue}
  }
  /// Returns true if `vehicle` has been explicitly set.
  var hasVehicle: Bool {return _storage._vehicle != nil}
  /// Clears the value of `vehicle`. Subsequent reads from it will return its default value.
  mutating func clearVehicle() {_uniqueStorage()._vehicle = nil}

  var alert: TransitRealtime_Alert {
    get {return _storage._alert ?? TransitRealtime_Alert()}
    set {_uniqueStorage()._alert = newValue}
  }
  /// Returns true if `alert` has been explicitly set.
  var hasAlert: Bool {return _storage._alert != nil}
  /// Clears the value of `alert`. Subsequent reads from it will return its default value.
  mutating func clearAlert() {_uniqueStorage()._alert = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TransitRealtime_TripUpdate: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var trip: TransitRealtime_TripDescriptor {
    get {return _trip ?? TransitRealtime_TripDescriptor()}
    set {_trip = newValue}
  }
  /// Returns true if `trip` has been explicitly set.
  var hasTrip: Bool {return self._trip != nil}
  /// Clears the value of `trip`. Subsequent reads from it will return its default value.
  mutating func clearTrip() {self._trip = nil}

  var vehicle: TransitRealtime_VehicleDescriptor {
    get {return _vehicle ?? TransitRealtime_VehicleDescriptor()}
    set {_vehicle = newValue}
  }
  /// Returns true if `vehicle` has been explicitly set.
  var hasVehicle: Bool {return self._vehicle != nil}
  /// Clears the value of `vehicle`. Subsequent reads from it will return its default value.
  mutating func clearVehicle() {self._vehicle = nil}

  var stopTimeUpdate: [TransitRealtime_TripUpdate.StopTimeUpdate] = []

  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  /// NEW	
  var delay: Int32 {
    get {return _delay ?? 0}
    set {_delay = newValue}
  }
  /// Returns true if `delay` has been explicitly set.
  var hasDelay: Bool {return self._delay != nil}
  /// Clears the value of `delay`. Subsequent reads from it will return its default value.
  mutating func clearDelay() {self._delay = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct StopTimeEvent: SwiftProtobuf.ExtensibleMessage, Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var delay: Int32 {
      get {return _delay ?? 0}
      set {_delay = newValue}
    }
    /// Returns true if `delay` has been explicitly set.
    var hasDelay: Bool {return self._delay != nil}
    /// Clears the value of `delay`. Subsequent reads from it will return its default value.
    mutating func clearDelay() {self._delay = nil}

    var time: Int64 {
      get {return _time ?? 0}
      set {_time = newValue}
    }
    /// Returns true if `time` has been explicitly set.
    var hasTime: Bool {return self._time != nil}
    /// Clears the value of `time`. Subsequent reads from it will return its default value.
    mutating func clearTime() {self._time = nil}

    var uncertainty: Int32 {
      get {return _uncertainty ?? 0}
      set {_uncertainty = newValue}
    }
    /// Returns true if `uncertainty` has been explicitly set.
    var hasUncertainty: Bool {return self._uncertainty != nil}
    /// Clears the value of `uncertainty`. Subsequent reads from it will return its default value.
    mutating func clearUncertainty() {self._uncertainty = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
    fileprivate var _delay: Int32? = nil
    fileprivate var _time: Int64? = nil
    fileprivate var _uncertainty: Int32? = nil
  }

  struct StopTimeUpdate: SwiftProtobuf.ExtensibleMessage, Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var stopSequence: UInt32 {
      get {return _stopSequence ?? 0}
      set {_stopSequence = newValue}
    }
    /// Returns true if `stopSequence` has been explicitly set.
    var hasStopSequence: Bool {return self._stopSequence != nil}
    /// Clears the value of `stopSequence`. Subsequent reads from it will return its default value.
    mutating func clearStopSequence() {self._stopSequence = nil}

    var stopID: String {
      get {return _stopID ?? String()}
      set {_stopID = newValue}
    }
    /// Returns true if `stopID` has been explicitly set.
    var hasStopID: Bool {return self._stopID != nil}
    /// Clears the value of `stopID`. Subsequent reads from it will return its default value.
    mutating func clearStopID() {self._stopID = nil}

    var arrival: TransitRealtime_TripUpdate.StopTimeEvent {
      get {return _arrival ?? TransitRealtime_TripUpdate.StopTimeEvent()}
      set {_arrival = newValue}
    }
    /// Returns true if `arrival` has been explicitly set.
    var hasArrival: Bool {return self._arrival != nil}
    /// Clears the value of `arrival`. Subsequent reads from it will return its default value.
    mutating func clearArrival() {self._arrival = nil}

    var departure: TransitRealtime_TripUpdate.StopTimeEvent {
      get {return _departure ?? TransitRealtime_TripUpdate.StopTimeEvent()}
      set {_departure = newValue}
    }
    /// Returns true if `departure` has been explicitly set.
    var hasDeparture: Bool {return self._departure != nil}
    /// Clears the value of `departure`. Subsequent reads from it will return its default value.
    mutating func clearDeparture() {self._departure = nil}

    var scheduleRelationship: TransitRealtime_TripUpdate.StopTimeUpdate.ScheduleRelationship {
      get {return _scheduleRelationship ?? .scheduled}
      set {_scheduleRelationship = newValue}
    }
    /// Returns true if `scheduleRelationship` has been explicitly set.
    var hasScheduleRelationship: Bool {return self._scheduleRelationship != nil}
    /// Clears the value of `scheduleRelationship`. Subsequent reads from it will return its default value.
    mutating func clearScheduleRelationship() {self._scheduleRelationship = nil}

    var departureOccupancyStatus: TransitRealtime_TripUpdate.StopTimeUpdate.OccupancyStatus {
      get {return _departureOccupancyStatus ?? .empty}
      set {_departureOccupancyStatus = newValue}
    }
    /// Returns true if `departureOccupancyStatus` has been explicitly set.
    var hasDepartureOccupancyStatus: Bool {return self._departureOccupancyStatus != nil}
    /// Clears the value of `departureOccupancyStatus`. Subsequent reads from it will return its default value.
    mutating func clearDepartureOccupancyStatus() {self._departureOccupancyStatus = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum ScheduleRelationship: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case scheduled // = 0
      case skipped // = 1
      case noData // = 2

      /// NEW
      case unscheduled // = 3

      init() {
        self = .scheduled
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .scheduled
        case 1: self = .skipped
        case 2: self = .noData
        case 3: self = .unscheduled
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .scheduled: return 0
        case .skipped: return 1
        case .noData: return 2
        case .unscheduled: return 3
        }
      }

    }

    enum OccupancyStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case empty // = 0
      case manySeatsAvailable // = 1
      case fewSeatsAvailable // = 2
      case standingRoomOnly // = 3
      case crushedStandingRoomOnly // = 4
      case full // = 5
      case notAcceptingPassengers // = 6

      init() {
        self = .empty
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .empty
        case 1: self = .manySeatsAvailable
        case 2: self = .fewSeatsAvailable
        case 3: self = .standingRoomOnly
        case 4: self = .crushedStandingRoomOnly
        case 5: self = .full
        case 6: self = .notAcceptingPassengers
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .empty: return 0
        case .manySeatsAvailable: return 1
        case .fewSeatsAvailable: return 2
        case .standingRoomOnly: return 3
        case .crushedStandingRoomOnly: return 4
        case .full: return 5
        case .notAcceptingPassengers: return 6
        }
      }

    }

    init() {}

    var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
    fileprivate var _stopSequence: UInt32? = nil
    fileprivate var _stopID: String? = nil
    fileprivate var _arrival: TransitRealtime_TripUpdate.StopTimeEvent? = nil
    fileprivate var _departure: TransitRealtime_TripUpdate.StopTimeEvent? = nil
    fileprivate var _scheduleRelationship: TransitRealtime_TripUpdate.StopTimeUpdate.ScheduleRelationship? = nil
    fileprivate var _departureOccupancyStatus: TransitRealtime_TripUpdate.StopTimeUpdate.OccupancyStatus? = nil
  }

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _trip: TransitRealtime_TripDescriptor? = nil
  fileprivate var _vehicle: TransitRealtime_VehicleDescriptor? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _delay: Int32? = nil
}

struct TransitRealtime_VehiclePosition: SwiftProtobuf.ExtensibleMessage, @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var trip: TransitRealtime_TripDescriptor {
    get {return _storage._trip ?? TransitRealtime_TripDescriptor()}
    set {_uniqueStorage()._trip = newValue}
  }
  /// Returns true if `trip` has been explicitly set.
  var hasTrip: Bool {return _storage._trip != nil}
  /// Clears the value of `trip`. Subsequent reads from it will return its default value.
  mutating func clearTrip() {_uniqueStorage()._trip = nil}

  var vehicle: TransitRealtime_VehicleDescriptor {
    get {return _storage._vehicle ?? TransitRealtime_VehicleDescriptor()}
    set {_uniqueStorage()._vehicle = newValue}
  }
  /// Returns true if `vehicle` has been explicitly set.
  var hasVehicle: Bool {return _storage._vehicle != nil}
  /// Clears the value of `vehicle`. Subsequent reads from it will return its default value.
  mutating func clearVehicle() {_uniqueStorage()._vehicle = nil}

  var position: TransitRealtime_Position {
    get {return _storage._position ?? TransitRealtime_Position()}
    set {_uniqueStorage()._position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return _storage._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {_uniqueStorage()._position = nil}

  var currentStopSequence: UInt32 {
    get {return _storage._currentStopSequence ?? 0}
    set {_uniqueStorage()._currentStopSequence = newValue}
  }
  /// Returns true if `currentStopSequence` has been explicitly set.
  var hasCurrentStopSequence: Bool {return _storage._currentStopSequence != nil}
  /// Clears the value of `currentStopSequence`. Subsequent reads from it will return its default value.
  mutating func clearCurrentStopSequence() {_uniqueStorage()._currentStopSequence = nil}

  var stopID: String {
    get {return _storage._stopID ?? String()}
    set {_uniqueStorage()._stopID = newValue}
  }
  /// Returns true if `stopID` has been explicitly set.
  var hasStopID: Bool {return _storage._stopID != nil}
  /// Clears the value of `stopID`. Subsequent reads from it will return its default value.
  mutating func clearStopID() {_uniqueStorage()._stopID = nil}

  var currentStatus: TransitRealtime_VehiclePosition.VehicleStopStatus {
    get {return _storage._currentStatus ?? .inTransitTo}
    set {_uniqueStorage()._currentStatus = newValue}
  }
  /// Returns true if `currentStatus` has been explicitly set.
  var hasCurrentStatus: Bool {return _storage._currentStatus != nil}
  /// Clears the value of `currentStatus`. Subsequent reads from it will return its default value.
  mutating func clearCurrentStatus() {_uniqueStorage()._currentStatus = nil}

  var timestamp: UInt64 {
    get {return _storage._timestamp ?? 0}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  var congestionLevel: TransitRealtime_VehiclePosition.CongestionLevel {
    get {return _storage._congestionLevel ?? .unknownCongestionLevel}
    set {_uniqueStorage()._congestionLevel = newValue}
  }
  /// Returns true if `congestionLevel` has been explicitly set.
  var hasCongestionLevel: Bool {return _storage._congestionLevel != nil}
  /// Clears the value of `congestionLevel`. Subsequent reads from it will return its default value.
  mutating func clearCongestionLevel() {_uniqueStorage()._congestionLevel = nil}

  var occupancyStatus: TransitRealtime_VehiclePosition.OccupancyStatus {
    get {return _storage._occupancyStatus ?? .empty}
    set {_uniqueStorage()._occupancyStatus = newValue}
  }
  /// Returns true if `occupancyStatus` has been explicitly set.
  var hasOccupancyStatus: Bool {return _storage._occupancyStatus != nil}
  /// Clears the value of `occupancyStatus`. Subsequent reads from it will return its default value.
  mutating func clearOccupancyStatus() {_uniqueStorage()._occupancyStatus = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum VehicleStopStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case incomingAt // = 0
    case stoppedAt // = 1
    case inTransitTo // = 2

    init() {
      self = .incomingAt
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .incomingAt
      case 1: self = .stoppedAt
      case 2: self = .inTransitTo
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .incomingAt: return 0
      case .stoppedAt: return 1
      case .inTransitTo: return 2
      }
    }

  }

  enum CongestionLevel: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknownCongestionLevel // = 0
    case runningSmoothly // = 1
    case stopAndGo // = 2
    case congestion // = 3

    /// NEW
    case severeCongestion // = 4

    init() {
      self = .unknownCongestionLevel
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownCongestionLevel
      case 1: self = .runningSmoothly
      case 2: self = .stopAndGo
      case 3: self = .congestion
      case 4: self = .severeCongestion
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownCongestionLevel: return 0
      case .runningSmoothly: return 1
      case .stopAndGo: return 2
      case .congestion: return 3
      case .severeCongestion: return 4
      }
    }

  }

  enum OccupancyStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case empty // = 0
    case manySeatsAvailable // = 1
    case fewSeatsAvailable // = 2
    case standingRoomOnly // = 3
    case crushedStandingRoomOnly // = 4
    case full // = 5
    case notAcceptingPassengers // = 6

    init() {
      self = .empty
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .empty
      case 1: self = .manySeatsAvailable
      case 2: self = .fewSeatsAvailable
      case 3: self = .standingRoomOnly
      case 4: self = .crushedStandingRoomOnly
      case 5: self = .full
      case 6: self = .notAcceptingPassengers
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .empty: return 0
      case .manySeatsAvailable: return 1
      case .fewSeatsAvailable: return 2
      case .standingRoomOnly: return 3
      case .crushedStandingRoomOnly: return 4
      case .full: return 5
      case .notAcceptingPassengers: return 6
      }
    }

  }

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TransitRealtime_Alert: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var activePeriod: [TransitRealtime_TimeRange] = []

  var informedEntity: [TransitRealtime_EntitySelector] = []

  var cause: TransitRealtime_Alert.Cause {
    get {return _cause ?? .unknownCause}
    set {_cause = newValue}
  }
  /// Returns true if `cause` has been explicitly set.
  var hasCause: Bool {return self._cause != nil}
  /// Clears the value of `cause`. Subsequent reads from it will return its default value.
  mutating func clearCause() {self._cause = nil}

  var effect: TransitRealtime_Alert.Effect {
    get {return _effect ?? .unknownEffect}
    set {_effect = newValue}
  }
  /// Returns true if `effect` has been explicitly set.
  var hasEffect: Bool {return self._effect != nil}
  /// Clears the value of `effect`. Subsequent reads from it will return its default value.
  mutating func clearEffect() {self._effect = nil}

  var url: TransitRealtime_TranslatedString {
    get {return _url ?? TransitRealtime_TranslatedString()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {self._url = nil}

  var headerText: TransitRealtime_TranslatedString {
    get {return _headerText ?? TransitRealtime_TranslatedString()}
    set {_headerText = newValue}
  }
  /// Returns true if `headerText` has been explicitly set.
  var hasHeaderText: Bool {return self._headerText != nil}
  /// Clears the value of `headerText`. Subsequent reads from it will return its default value.
  mutating func clearHeaderText() {self._headerText = nil}

  var descriptionText: TransitRealtime_TranslatedString {
    get {return _descriptionText ?? TransitRealtime_TranslatedString()}
    set {_descriptionText = newValue}
  }
  /// Returns true if `descriptionText` has been explicitly set.
  var hasDescriptionText: Bool {return self._descriptionText != nil}
  /// Clears the value of `descriptionText`. Subsequent reads from it will return its default value.
  mutating func clearDescriptionText() {self._descriptionText = nil}

  /// NEW
  var ttsHeaderText: TransitRealtime_TranslatedString {
    get {return _ttsHeaderText ?? TransitRealtime_TranslatedString()}
    set {_ttsHeaderText = newValue}
  }
  /// Returns true if `ttsHeaderText` has been explicitly set.
  var hasTtsHeaderText: Bool {return self._ttsHeaderText != nil}
  /// Clears the value of `ttsHeaderText`. Subsequent reads from it will return its default value.
  mutating func clearTtsHeaderText() {self._ttsHeaderText = nil}

  /// NEW
  var ttsDescriptionText: TransitRealtime_TranslatedString {
    get {return _ttsDescriptionText ?? TransitRealtime_TranslatedString()}
    set {_ttsDescriptionText = newValue}
  }
  /// Returns true if `ttsDescriptionText` has been explicitly set.
  var hasTtsDescriptionText: Bool {return self._ttsDescriptionText != nil}
  /// Clears the value of `ttsDescriptionText`. Subsequent reads from it will return its default value.
  mutating func clearTtsDescriptionText() {self._ttsDescriptionText = nil}

  /// NEW
  var severityLevel: TransitRealtime_Alert.SeverityLevel {
    get {return _severityLevel ?? .unknownSeverity}
    set {_severityLevel = newValue}
  }
  /// Returns true if `severityLevel` has been explicitly set.
  var hasSeverityLevel: Bool {return self._severityLevel != nil}
  /// Clears the value of `severityLevel`. Subsequent reads from it will return its default value.
  mutating func clearSeverityLevel() {self._severityLevel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Cause: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknownCause // = 1

    /// NEW
    case otherCause // = 2
    case technicalProblem // = 3

    /// NEW
    case strike // = 4

    /// NEW
    case demonstration // = 5
    case accident // = 6
    case holiday // = 7
    case weather // = 8
    case maintenance // = 9
    case construction // = 10
    case policeActivity // = 11
    case medicalEmergency // = 12

    init() {
      self = .unknownCause
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .unknownCause
      case 2: self = .otherCause
      case 3: self = .technicalProblem
      case 4: self = .strike
      case 5: self = .demonstration
      case 6: self = .accident
      case 7: self = .holiday
      case 8: self = .weather
      case 9: self = .maintenance
      case 10: self = .construction
      case 11: self = .policeActivity
      case 12: self = .medicalEmergency
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownCause: return 1
      case .otherCause: return 2
      case .technicalProblem: return 3
      case .strike: return 4
      case .demonstration: return 5
      case .accident: return 6
      case .holiday: return 7
      case .weather: return 8
      case .maintenance: return 9
      case .construction: return 10
      case .policeActivity: return 11
      case .medicalEmergency: return 12
      }
    }

  }

  enum Effect: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case noService // = 1
    case reducedService // = 2
    case significantDelays // = 3
    case detour // = 4
    case additionalService // = 5
    case modifiedService // = 6
    case otherEffect // = 7
    case unknownEffect // = 8
    case stopMoved // = 9

    /// NEW
    case noEffect // = 10

    /// NEW
    case accessibilityIssue // = 11

    init() {
      self = .noService
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .noService
      case 2: self = .reducedService
      case 3: self = .significantDelays
      case 4: self = .detour
      case 5: self = .additionalService
      case 6: self = .modifiedService
      case 7: self = .otherEffect
      case 8: self = .unknownEffect
      case 9: self = .stopMoved
      case 10: self = .noEffect
      case 11: self = .accessibilityIssue
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .noService: return 1
      case .reducedService: return 2
      case .significantDelays: return 3
      case .detour: return 4
      case .additionalService: return 5
      case .modifiedService: return 6
      case .otherEffect: return 7
      case .unknownEffect: return 8
      case .stopMoved: return 9
      case .noEffect: return 10
      case .accessibilityIssue: return 11
      }
    }

  }

  /// NEW
  enum SeverityLevel: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknownSeverity // = 1
    case info // = 2
    case warning // = 3
    case severe // = 4

    init() {
      self = .unknownSeverity
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .unknownSeverity
      case 2: self = .info
      case 3: self = .warning
      case 4: self = .severe
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownSeverity: return 1
      case .info: return 2
      case .warning: return 3
      case .severe: return 4
      }
    }

  }

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _cause: TransitRealtime_Alert.Cause? = nil
  fileprivate var _effect: TransitRealtime_Alert.Effect? = nil
  fileprivate var _url: TransitRealtime_TranslatedString? = nil
  fileprivate var _headerText: TransitRealtime_TranslatedString? = nil
  fileprivate var _descriptionText: TransitRealtime_TranslatedString? = nil
  fileprivate var _ttsHeaderText: TransitRealtime_TranslatedString? = nil
  fileprivate var _ttsDescriptionText: TransitRealtime_TranslatedString? = nil
  fileprivate var _severityLevel: TransitRealtime_Alert.SeverityLevel? = nil
}

/// NEW
/// An addition to the GTFS static bundle
struct TransitRealtime_UpdateBundle: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the name of the bundle to be updated. This is to allow consumers to update the correct bundle
  var gtfsstaticBundle: String {
    get {return _gtfsstaticBundle ?? String()}
    set {_gtfsstaticBundle = newValue}
  }
  /// Returns true if `gtfsstaticBundle` has been explicitly set.
  var hasGtfsstaticBundle: Bool {return self._gtfsstaticBundle != nil}
  /// Clears the value of `gtfsstaticBundle`. Subsequent reads from it will return its default value.
  mutating func clearGtfsstaticBundle() {self._gtfsstaticBundle = nil}

  /// This field is the update sequence ID. It should commence at 1 for the first update to a static bundle and increment by 1 for each successive update
  /// The intent of this field is to allow the consumer to identify updates they may already have processed.
  var updateSequence: Int32 {
    get {return _updateSequence ?? 0}
    set {_updateSequence = newValue}
  }
  /// Returns true if `updateSequence` has been explicitly set.
  var hasUpdateSequence: Bool {return self._updateSequence != nil}
  /// Clears the value of `updateSequence`. Subsequent reads from it will return its default value.
  mutating func clearUpdateSequence() {self._updateSequence = nil}

  /// repeated field to cancel scheduled trips in the bundle. This is the trip_id to cancel.
  var cancelledTrip: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _gtfsstaticBundle: String? = nil
  fileprivate var _updateSequence: Int32? = nil
}

struct TransitRealtime_TimeRange: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var start: UInt64 {
    get {return _start ?? 0}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  var end: UInt64 {
    get {return _end ?? 0}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  mutating func clearEnd() {self._end = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _start: UInt64? = nil
  fileprivate var _end: UInt64? = nil
}

struct TransitRealtime_Position: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var latitude: Float {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  var longitude: Float {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var bearing: Float {
    get {return _bearing ?? 0}
    set {_bearing = newValue}
  }
  /// Returns true if `bearing` has been explicitly set.
  var hasBearing: Bool {return self._bearing != nil}
  /// Clears the value of `bearing`. Subsequent reads from it will return its default value.
  mutating func clearBearing() {self._bearing = nil}

  var odometer: Double {
    get {return _odometer ?? 0}
    set {_odometer = newValue}
  }
  /// Returns true if `odometer` has been explicitly set.
  var hasOdometer: Bool {return self._odometer != nil}
  /// Clears the value of `odometer`. Subsequent reads from it will return its default value.
  mutating func clearOdometer() {self._odometer = nil}

  var speed: Float {
    get {return _speed ?? 0}
    set {_speed = newValue}
  }
  /// Returns true if `speed` has been explicitly set.
  var hasSpeed: Bool {return self._speed != nil}
  /// Clears the value of `speed`. Subsequent reads from it will return its default value.
  mutating func clearSpeed() {self._speed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _latitude: Float? = nil
  fileprivate var _longitude: Float? = nil
  fileprivate var _bearing: Float? = nil
  fileprivate var _odometer: Double? = nil
  fileprivate var _speed: Float? = nil
}

struct TransitRealtime_TripDescriptor: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tripID: String {
    get {return _tripID ?? String()}
    set {_tripID = newValue}
  }
  /// Returns true if `tripID` has been explicitly set.
  var hasTripID: Bool {return self._tripID != nil}
  /// Clears the value of `tripID`. Subsequent reads from it will return its default value.
  mutating func clearTripID() {self._tripID = nil}

  var routeID: String {
    get {return _routeID ?? String()}
    set {_routeID = newValue}
  }
  /// Returns true if `routeID` has been explicitly set.
  var hasRouteID: Bool {return self._routeID != nil}
  /// Clears the value of `routeID`. Subsequent reads from it will return its default value.
  mutating func clearRouteID() {self._routeID = nil}

  /// NEW
  var directionID: UInt32 {
    get {return _directionID ?? 0}
    set {_directionID = newValue}
  }
  /// Returns true if `directionID` has been explicitly set.
  var hasDirectionID: Bool {return self._directionID != nil}
  /// Clears the value of `directionID`. Subsequent reads from it will return its default value.
  mutating func clearDirectionID() {self._directionID = nil}

  var startTime: String {
    get {return _startTime ?? String()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {self._startTime = nil}

  var startDate: String {
    get {return _startDate ?? String()}
    set {_startDate = newValue}
  }
  /// Returns true if `startDate` has been explicitly set.
  var hasStartDate: Bool {return self._startDate != nil}
  /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
  mutating func clearStartDate() {self._startDate = nil}

  var scheduleRelationship: TransitRealtime_TripDescriptor.ScheduleRelationship {
    get {return _scheduleRelationship ?? .scheduled}
    set {_scheduleRelationship = newValue}
  }
  /// Returns true if `scheduleRelationship` has been explicitly set.
  var hasScheduleRelationship: Bool {return self._scheduleRelationship != nil}
  /// Clears the value of `scheduleRelationship`. Subsequent reads from it will return its default value.
  mutating func clearScheduleRelationship() {self._scheduleRelationship = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ScheduleRelationship: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case scheduled // = 0
    case added // = 1
    case unscheduled // = 2
    case canceled // = 3

    /// KEEP IT
    case replacement // = 5

    init() {
      self = .scheduled
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .scheduled
      case 1: self = .added
      case 2: self = .unscheduled
      case 3: self = .canceled
      case 5: self = .replacement
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .scheduled: return 0
      case .added: return 1
      case .unscheduled: return 2
      case .canceled: return 3
      case .replacement: return 5
      }
    }

  }

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _tripID: String? = nil
  fileprivate var _routeID: String? = nil
  fileprivate var _directionID: UInt32? = nil
  fileprivate var _startTime: String? = nil
  fileprivate var _startDate: String? = nil
  fileprivate var _scheduleRelationship: TransitRealtime_TripDescriptor.ScheduleRelationship? = nil
}

struct TransitRealtime_VehicleDescriptor: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var label: String {
    get {return _label ?? String()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {self._label = nil}

  var licensePlate: String {
    get {return _licensePlate ?? String()}
    set {_licensePlate = newValue}
  }
  /// Returns true if `licensePlate` has been explicitly set.
  var hasLicensePlate: Bool {return self._licensePlate != nil}
  /// Clears the value of `licensePlate`. Subsequent reads from it will return its default value.
  mutating func clearLicensePlate() {self._licensePlate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _id: String? = nil
  fileprivate var _label: String? = nil
  fileprivate var _licensePlate: String? = nil
}

/// NEW
struct TransitRealtime_TfnswVehicleDescriptor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var airConditioned: Bool {
    get {return _airConditioned ?? false}
    set {_airConditioned = newValue}
  }
  /// Returns true if `airConditioned` has been explicitly set.
  var hasAirConditioned: Bool {return self._airConditioned != nil}
  /// Clears the value of `airConditioned`. Subsequent reads from it will return its default value.
  mutating func clearAirConditioned() {self._airConditioned = nil}

  var wheelchairAccessible: Int32 {
    get {return _wheelchairAccessible ?? 0}
    set {_wheelchairAccessible = newValue}
  }
  /// Returns true if `wheelchairAccessible` has been explicitly set.
  var hasWheelchairAccessible: Bool {return self._wheelchairAccessible != nil}
  /// Clears the value of `wheelchairAccessible`. Subsequent reads from it will return its default value.
  mutating func clearWheelchairAccessible() {self._wheelchairAccessible = nil}

  var vehicleModel: String {
    get {return _vehicleModel ?? String()}
    set {_vehicleModel = newValue}
  }
  /// Returns true if `vehicleModel` has been explicitly set.
  var hasVehicleModel: Bool {return self._vehicleModel != nil}
  /// Clears the value of `vehicleModel`. Subsequent reads from it will return its default value.
  mutating func clearVehicleModel() {self._vehicleModel = nil}

  var performingPriorTrip: Bool {
    get {return _performingPriorTrip ?? false}
    set {_performingPriorTrip = newValue}
  }
  /// Returns true if `performingPriorTrip` has been explicitly set.
  var hasPerformingPriorTrip: Bool {return self._performingPriorTrip != nil}
  /// Clears the value of `performingPriorTrip`. Subsequent reads from it will return its default value.
  mutating func clearPerformingPriorTrip() {self._performingPriorTrip = nil}

  var specialVehicleAttributes: Int32 {
    get {return _specialVehicleAttributes ?? 0}
    set {_specialVehicleAttributes = newValue}
  }
  /// Returns true if `specialVehicleAttributes` has been explicitly set.
  var hasSpecialVehicleAttributes: Bool {return self._specialVehicleAttributes != nil}
  /// Clears the value of `specialVehicleAttributes`. Subsequent reads from it will return its default value.
  mutating func clearSpecialVehicleAttributes() {self._specialVehicleAttributes = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _airConditioned: Bool? = nil
  fileprivate var _wheelchairAccessible: Int32? = nil
  fileprivate var _vehicleModel: String? = nil
  fileprivate var _performingPriorTrip: Bool? = nil
  fileprivate var _specialVehicleAttributes: Int32? = nil
}

/// NEW 
struct TransitRealtime_CarriageDescriptor: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var positionInConsist: Int32 {
    get {return _positionInConsist ?? 0}
    set {_positionInConsist = newValue}
  }
  /// Returns true if `positionInConsist` has been explicitly set.
  var hasPositionInConsist: Bool {return self._positionInConsist != nil}
  /// Clears the value of `positionInConsist`. Subsequent reads from it will return its default value.
  mutating func clearPositionInConsist() {self._positionInConsist = nil}

  var occupancyStatus: TransitRealtime_CarriageDescriptor.OccupancyStatus {
    get {return _occupancyStatus ?? .empty}
    set {_occupancyStatus = newValue}
  }
  /// Returns true if `occupancyStatus` has been explicitly set.
  var hasOccupancyStatus: Bool {return self._occupancyStatus != nil}
  /// Clears the value of `occupancyStatus`. Subsequent reads from it will return its default value.
  mutating func clearOccupancyStatus() {self._occupancyStatus = nil}

  var quietCarriage: Bool {
    get {return _quietCarriage ?? false}
    set {_quietCarriage = newValue}
  }
  /// Returns true if `quietCarriage` has been explicitly set.
  var hasQuietCarriage: Bool {return self._quietCarriage != nil}
  /// Clears the value of `quietCarriage`. Subsequent reads from it will return its default value.
  mutating func clearQuietCarriage() {self._quietCarriage = nil}

  var toilet: TransitRealtime_CarriageDescriptor.ToiletStatus {
    get {return _toilet ?? .none}
    set {_toilet = newValue}
  }
  /// Returns true if `toilet` has been explicitly set.
  var hasToilet: Bool {return self._toilet != nil}
  /// Clears the value of `toilet`. Subsequent reads from it will return its default value.
  mutating func clearToilet() {self._toilet = nil}

  var luggageRack: Bool {
    get {return _luggageRack ?? false}
    set {_luggageRack = newValue}
  }
  /// Returns true if `luggageRack` has been explicitly set.
  var hasLuggageRack: Bool {return self._luggageRack != nil}
  /// Clears the value of `luggageRack`. Subsequent reads from it will return its default value.
  mutating func clearLuggageRack() {self._luggageRack = nil}

  ///08/6/22 - Changed to Departure Occupancy Status to ensure its in line with GTFS-R Specifications(https://github.com/google/transit/blob/master/gtfs-realtime/spec/en/reference.md#message-stoptimeevent)
  var departureOccupancyStatus: TransitRealtime_CarriageDescriptor.OccupancyStatus {
    get {return _departureOccupancyStatus ?? .empty}
    set {_departureOccupancyStatus = newValue}
  }
  /// Returns true if `departureOccupancyStatus` has been explicitly set.
  var hasDepartureOccupancyStatus: Bool {return self._departureOccupancyStatus != nil}
  /// Clears the value of `departureOccupancyStatus`. Subsequent reads from it will return its default value.
  mutating func clearDepartureOccupancyStatus() {self._departureOccupancyStatus = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OccupancyStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case empty // = 0
    case manySeatsAvailable // = 1
    case fewSeatsAvailable // = 2
    case standingRoomOnly // = 3
    case crushedStandingRoomOnly // = 4
    case full // = 5

    init() {
      self = .empty
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .empty
      case 1: self = .manySeatsAvailable
      case 2: self = .fewSeatsAvailable
      case 3: self = .standingRoomOnly
      case 4: self = .crushedStandingRoomOnly
      case 5: self = .full
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .empty: return 0
      case .manySeatsAvailable: return 1
      case .fewSeatsAvailable: return 2
      case .standingRoomOnly: return 3
      case .crushedStandingRoomOnly: return 4
      case .full: return 5
      }
    }

  }

  enum ToiletStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case none // = 0
    case normal // = 1
    case accessible // = 2

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .normal
      case 2: self = .accessible
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .normal: return 1
      case .accessible: return 2
      }
    }

  }

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _name: String? = nil
  fileprivate var _positionInConsist: Int32? = nil
  fileprivate var _occupancyStatus: TransitRealtime_CarriageDescriptor.OccupancyStatus? = nil
  fileprivate var _quietCarriage: Bool? = nil
  fileprivate var _toilet: TransitRealtime_CarriageDescriptor.ToiletStatus? = nil
  fileprivate var _luggageRack: Bool? = nil
  fileprivate var _departureOccupancyStatus: TransitRealtime_CarriageDescriptor.OccupancyStatus? = nil
}

struct TransitRealtime_EntitySelector: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var agencyID: String {
    get {return _agencyID ?? String()}
    set {_agencyID = newValue}
  }
  /// Returns true if `agencyID` has been explicitly set.
  var hasAgencyID: Bool {return self._agencyID != nil}
  /// Clears the value of `agencyID`. Subsequent reads from it will return its default value.
  mutating func clearAgencyID() {self._agencyID = nil}

  var routeID: String {
    get {return _routeID ?? String()}
    set {_routeID = newValue}
  }
  /// Returns true if `routeID` has been explicitly set.
  var hasRouteID: Bool {return self._routeID != nil}
  /// Clears the value of `routeID`. Subsequent reads from it will return its default value.
  mutating func clearRouteID() {self._routeID = nil}

  var routeType: Int32 {
    get {return _routeType ?? 0}
    set {_routeType = newValue}
  }
  /// Returns true if `routeType` has been explicitly set.
  var hasRouteType: Bool {return self._routeType != nil}
  /// Clears the value of `routeType`. Subsequent reads from it will return its default value.
  mutating func clearRouteType() {self._routeType = nil}

  var trip: TransitRealtime_TripDescriptor {
    get {return _trip ?? TransitRealtime_TripDescriptor()}
    set {_trip = newValue}
  }
  /// Returns true if `trip` has been explicitly set.
  var hasTrip: Bool {return self._trip != nil}
  /// Clears the value of `trip`. Subsequent reads from it will return its default value.
  mutating func clearTrip() {self._trip = nil}

  var stopID: String {
    get {return _stopID ?? String()}
    set {_stopID = newValue}
  }
  /// Returns true if `stopID` has been explicitly set.
  var hasStopID: Bool {return self._stopID != nil}
  /// Clears the value of `stopID`. Subsequent reads from it will return its default value.
  mutating func clearStopID() {self._stopID = nil}

  /// NEW
  var directionID: UInt32 {
    get {return _directionID ?? 0}
    set {_directionID = newValue}
  }
  /// Returns true if `directionID` has been explicitly set.
  var hasDirectionID: Bool {return self._directionID != nil}
  /// Clears the value of `directionID`. Subsequent reads from it will return its default value.
  mutating func clearDirectionID() {self._directionID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _agencyID: String? = nil
  fileprivate var _routeID: String? = nil
  fileprivate var _routeType: Int32? = nil
  fileprivate var _trip: TransitRealtime_TripDescriptor? = nil
  fileprivate var _stopID: String? = nil
  fileprivate var _directionID: UInt32? = nil
}

struct TransitRealtime_TranslatedString: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var translation: [TransitRealtime_TranslatedString.Translation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Translation: SwiftProtobuf.ExtensibleMessage, Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var text: String {
      get {return _text ?? String()}
      set {_text = newValue}
    }
    /// Returns true if `text` has been explicitly set.
    var hasText: Bool {return self._text != nil}
    /// Clears the value of `text`. Subsequent reads from it will return its default value.
    mutating func clearText() {self._text = nil}

    var language: String {
      get {return _language ?? String()}
      set {_language = newValue}
    }
    /// Returns true if `language` has been explicitly set.
    var hasLanguage: Bool {return self._language != nil}
    /// Clears the value of `language`. Subsequent reads from it will return its default value.
    mutating func clearLanguage() {self._language = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
    fileprivate var _text: String? = nil
    fileprivate var _language: String? = nil
  }

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
}

// MARK: - Extension support defined in gtfs-realtime_1007_extension.proto.

// MARK: - Extension Properties

// Swift Extensions on the extended Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension TransitRealtime_FeedEntity {

  /// NEW
  var TransitRealtime_update: TransitRealtime_UpdateBundle {
    get {return getExtensionValue(ext: TransitRealtime_Extensions_update) ?? TransitRealtime_UpdateBundle()}
    set {setExtensionValue(ext: TransitRealtime_Extensions_update, value: newValue)}
  }
  /// Returns true if extension `TransitRealtime_Extensions_update`
  /// has been explicitly set.
  var hasTransitRealtime_update: Bool {
    return hasExtensionValue(ext: TransitRealtime_Extensions_update)
  }
  /// Clears the value of extension `TransitRealtime_Extensions_update`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTransitRealtime_update() {
    clearExtensionValue(ext: TransitRealtime_Extensions_update)
  }
}

extension TransitRealtime_Position {

  /// NEW
  var TransitRealtime_trackDirection: TransitRealtime_TrackDirection {
    get {return getExtensionValue(ext: TransitRealtime_Extensions_track_direction) ?? .up}
    set {setExtensionValue(ext: TransitRealtime_Extensions_track_direction, value: newValue)}
  }
  /// Returns true if extension `TransitRealtime_Extensions_track_direction`
  /// has been explicitly set.
  var hasTransitRealtime_trackDirection: Bool {
    return hasExtensionValue(ext: TransitRealtime_Extensions_track_direction)
  }
  /// Clears the value of extension `TransitRealtime_Extensions_track_direction`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTransitRealtime_trackDirection() {
    clearExtensionValue(ext: TransitRealtime_Extensions_track_direction)
  }
}

extension TransitRealtime_TripUpdate.StopTimeUpdate {

  /// NEW - 22/2/22 - Predictive Real Time Occupancy added to TripUpdate->Stop Time Update
  var TransitRealtime_carriageSeqPredictiveOccupancy: [TransitRealtime_CarriageDescriptor] {
    get {return getExtensionValue(ext: TransitRealtime_Extensions_carriage_seq_predictive_occupancy) ?? []}
    set {setExtensionValue(ext: TransitRealtime_Extensions_carriage_seq_predictive_occupancy, value: newValue)}
  }
}

extension TransitRealtime_VehicleDescriptor {

  /// NEW
  var TransitRealtime_tfnswVehicleDescriptor: TransitRealtime_TfnswVehicleDescriptor {
    get {return getExtensionValue(ext: TransitRealtime_Extensions_tfnsw_vehicle_descriptor) ?? TransitRealtime_TfnswVehicleDescriptor()}
    set {setExtensionValue(ext: TransitRealtime_Extensions_tfnsw_vehicle_descriptor, value: newValue)}
  }
  /// Returns true if extension `TransitRealtime_Extensions_tfnsw_vehicle_descriptor`
  /// has been explicitly set.
  var hasTransitRealtime_tfnswVehicleDescriptor: Bool {
    return hasExtensionValue(ext: TransitRealtime_Extensions_tfnsw_vehicle_descriptor)
  }
  /// Clears the value of extension `TransitRealtime_Extensions_tfnsw_vehicle_descriptor`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTransitRealtime_tfnswVehicleDescriptor() {
    clearExtensionValue(ext: TransitRealtime_Extensions_tfnsw_vehicle_descriptor)
  }
}

extension TransitRealtime_VehiclePosition {

  var TransitRealtime_consist: [TransitRealtime_CarriageDescriptor] {
    get {return getExtensionValue(ext: TransitRealtime_Extensions_consist) ?? []}
    set {setExtensionValue(ext: TransitRealtime_Extensions_consist, value: newValue)}
  }

}

// MARK: - File's ExtensionMap: TransitRealtime_Gtfs_u45Realtime1007Extension_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
let TransitRealtime_Gtfs_u45Realtime1007Extension_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  TransitRealtime_Extensions_update,
  TransitRealtime_Extensions_consist,
  TransitRealtime_Extensions_track_direction,
  TransitRealtime_Extensions_tfnsw_vehicle_descriptor,
  TransitRealtime_Extensions_carriage_seq_predictive_occupancy
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

/// NEW
let TransitRealtime_Extensions_update = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TransitRealtime_UpdateBundle>, TransitRealtime_FeedEntity>(
  _protobuf_fieldNumber: 1007,
  fieldName: "transit_realtime.update"
)

let TransitRealtime_Extensions_consist = SwiftProtobuf.MessageExtension<SwiftProtobuf.RepeatedMessageExtensionField<TransitRealtime_CarriageDescriptor>, TransitRealtime_VehiclePosition>(
  _protobuf_fieldNumber: 1007,
  fieldName: "transit_realtime.consist"
)

/// NEW
let TransitRealtime_Extensions_track_direction = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalEnumExtensionField<TransitRealtime_TrackDirection>, TransitRealtime_Position>(
  _protobuf_fieldNumber: 1007,
  fieldName: "transit_realtime.track_direction"
)

/// NEW
let TransitRealtime_Extensions_tfnsw_vehicle_descriptor = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TransitRealtime_TfnswVehicleDescriptor>, TransitRealtime_VehicleDescriptor>(
  _protobuf_fieldNumber: 1007,
  fieldName: "transit_realtime.tfnsw_vehicle_descriptor"
)

/// NEW - 22/2/22 - Predictive Real Time Occupancy added to TripUpdate->Stop Time Update
let TransitRealtime_Extensions_carriage_seq_predictive_occupancy = SwiftProtobuf.MessageExtension<SwiftProtobuf.RepeatedMessageExtensionField<TransitRealtime_CarriageDescriptor>, TransitRealtime_TripUpdate.StopTimeUpdate>(
  _protobuf_fieldNumber: 1007,
  fieldName: "transit_realtime.carriage_seq_predictive_occupancy"
)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "transit_realtime"

extension TransitRealtime_TrackDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UP"),
    1: .same(proto: "DOWN"),
  ]
}

extension TransitRealtime_FeedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "entity"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if self._header == nil {return false}
    if let v = self._header, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.entity) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entity) }()
      case 1000..<2000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_FeedMessage.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.entity.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entity, fieldNumber: 2)
    }
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 2000)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransitRealtime_FeedMessage, rhs: TransitRealtime_FeedMessage) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.entity != rhs.entity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_FeedHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeedHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gtfs_realtime_version"),
    2: .same(proto: "incrementality"),
    3: .same(proto: "timestamp"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if self._gtfsRealtimeVersion == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._gtfsRealtimeVersion) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._incrementality) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 1000..<2000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_FeedHeader.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._gtfsRealtimeVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._incrementality {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 2000)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransitRealtime_FeedHeader, rhs: TransitRealtime_FeedHeader) -> Bool {
    if lhs._gtfsRealtimeVersion != rhs._gtfsRealtimeVersion {return false}
    if lhs._incrementality != rhs._incrementality {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_FeedHeader.Incrementality: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FULL_DATASET"),
    1: .same(proto: "DIFFERENTIAL"),
  ]
}

extension TransitRealtime_FeedEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeedEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "is_deleted"),
    3: .standard(proto: "trip_update"),
    4: .same(proto: "vehicle"),
    5: .same(proto: "alert"),
  ]

  fileprivate class _StorageClass {
    var _id: String? = nil
    var _isDeleted: Bool? = nil
    var _tripUpdate: TransitRealtime_TripUpdate? = nil
    var _vehicle: TransitRealtime_VehiclePosition? = nil
    var _alert: TransitRealtime_Alert? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _isDeleted = source._isDeleted
      _tripUpdate = source._tripUpdate
      _vehicle = source._vehicle
      _alert = source._alert
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id == nil {return false}
      if let v = _storage._tripUpdate, !v.isInitialized {return false}
      if let v = _storage._vehicle, !v.isInitialized {return false}
      if let v = _storage._alert, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._isDeleted) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._tripUpdate) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._vehicle) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._alert) }()
        case 1000..<2000:
          try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_FeedEntity.self, fieldNumber: fieldNumber) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._isDeleted {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._tripUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._vehicle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._alert {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 2000)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransitRealtime_FeedEntity, rhs: TransitRealtime_FeedEntity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._isDeleted != rhs_storage._isDeleted {return false}
        if _storage._tripUpdate != rhs_storage._tripUpdate {return false}
        if _storage._vehicle != rhs_storage._vehicle {return false}
        if _storage._alert != rhs_storage._alert {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TripUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TripUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trip"),
    3: .same(proto: "vehicle"),
    2: .standard(proto: "stop_time_update"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "delay"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if self._trip == nil {return false}
    if let v = self._trip, !v.isInitialized {return false}
    if let v = self._vehicle, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.stopTimeUpdate) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._trip) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.stopTimeUpdate) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._vehicle) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._delay) }()
      case 1000..<2000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TripUpdate.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._trip {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.stopTimeUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stopTimeUpdate, fieldNumber: 2)
    }
    try { if let v = self._vehicle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._delay {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 2000)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransitRealtime_TripUpdate, rhs: TransitRealtime_TripUpdate) -> Bool {
    if lhs._trip != rhs._trip {return false}
    if lhs._vehicle != rhs._vehicle {return false}
    if lhs.stopTimeUpdate != rhs.stopTimeUpdate {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._delay != rhs._delay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TripUpdate.StopTimeEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TransitRealtime_TripUpdate.protoMessageName + ".StopTimeEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "delay"),
    2: .same(proto: "time"),
    3: .same(proto: "uncertainty"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._delay) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._time) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._uncertainty) }()
      case 1000..<2000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TripUpdate.StopTimeEvent.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._delay {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._uncertainty {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 2000)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransitRealtime_TripUpdate.StopTimeEvent, rhs: TransitRealtime_TripUpdate.StopTimeEvent) -> Bool {
    if lhs._delay != rhs._delay {return false}
    if lhs._time != rhs._time {return false}
    if lhs._uncertainty != rhs._uncertainty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TripUpdate.StopTimeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TransitRealtime_TripUpdate.protoMessageName + ".StopTimeUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stop_sequence"),
    4: .standard(proto: "stop_id"),
    2: .same(proto: "arrival"),
    3: .same(proto: "departure"),
    5: .standard(proto: "schedule_relationship"),
    6: .standard(proto: "departure_occupancy_status"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._arrival, !v.isInitialized {return false}
    if let v = self._departure, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._stopSequence) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._arrival) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._departure) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._stopID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._scheduleRelationship) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._departureOccupancyStatus) }()
      case 1000..<2000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TripUpdate.StopTimeUpdate.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stopSequence {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._arrival {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._departure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._stopID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._scheduleRelationship {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._departureOccupancyStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 2000)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransitRealtime_TripUpdate.StopTimeUpdate, rhs: TransitRealtime_TripUpdate.StopTimeUpdate) -> Bool {
    if lhs._stopSequence != rhs._stopSequence {return false}
    if lhs._stopID != rhs._stopID {return false}
    if lhs._arrival != rhs._arrival {return false}
    if lhs._departure != rhs._departure {return false}
    if lhs._scheduleRelationship != rhs._scheduleRelationship {return false}
    if lhs._departureOccupancyStatus != rhs._departureOccupancyStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TripUpdate.StopTimeUpdate.ScheduleRelationship: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SCHEDULED"),
    1: .same(proto: "SKIPPED"),
    2: .same(proto: "NO_DATA"),
    3: .same(proto: "UNSCHEDULED"),
  ]
}

extension TransitRealtime_TripUpdate.StopTimeUpdate.OccupancyStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EMPTY"),
    1: .same(proto: "MANY_SEATS_AVAILABLE"),
    2: .same(proto: "FEW_SEATS_AVAILABLE"),
    3: .same(proto: "STANDING_ROOM_ONLY"),
    4: .same(proto: "CRUSHED_STANDING_ROOM_ONLY"),
    5: .same(proto: "FULL"),
    6: .same(proto: "NOT_ACCEPTING_PASSENGERS"),
  ]
}

extension TransitRealtime_VehiclePosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehiclePosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trip"),
    8: .same(proto: "vehicle"),
    2: .same(proto: "position"),
    3: .standard(proto: "current_stop_sequence"),
    7: .standard(proto: "stop_id"),
    4: .standard(proto: "current_status"),
    5: .same(proto: "timestamp"),
    6: .standard(proto: "congestion_level"),
    9: .standard(proto: "occupancy_status"),
  ]

  fileprivate class _StorageClass {
    var _trip: TransitRealtime_TripDescriptor? = nil
    var _vehicle: TransitRealtime_VehicleDescriptor? = nil
    var _position: TransitRealtime_Position? = nil
    var _currentStopSequence: UInt32? = nil
    var _stopID: String? = nil
    var _currentStatus: TransitRealtime_VehiclePosition.VehicleStopStatus? = nil
    var _timestamp: UInt64? = nil
    var _congestionLevel: TransitRealtime_VehiclePosition.CongestionLevel? = nil
    var _occupancyStatus: TransitRealtime_VehiclePosition.OccupancyStatus? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _trip = source._trip
      _vehicle = source._vehicle
      _position = source._position
      _currentStopSequence = source._currentStopSequence
      _stopID = source._stopID
      _currentStatus = source._currentStatus
      _timestamp = source._timestamp
      _congestionLevel = source._congestionLevel
      _occupancyStatus = source._occupancyStatus
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._trip, !v.isInitialized {return false}
      if let v = _storage._vehicle, !v.isInitialized {return false}
      if let v = _storage._position, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._trip) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._position) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._currentStopSequence) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._currentStatus) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._timestamp) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._congestionLevel) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._stopID) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._vehicle) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._occupancyStatus) }()
        case 1000..<2000:
          try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_VehiclePosition.self, fieldNumber: fieldNumber) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._trip {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._position {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._currentStopSequence {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._currentStatus {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._timestamp {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._congestionLevel {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._stopID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._vehicle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._occupancyStatus {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
      } }()
      try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 2000)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransitRealtime_VehiclePosition, rhs: TransitRealtime_VehiclePosition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._trip != rhs_storage._trip {return false}
        if _storage._vehicle != rhs_storage._vehicle {return false}
        if _storage._position != rhs_storage._position {return false}
        if _storage._currentStopSequence != rhs_storage._currentStopSequence {return false}
        if _storage._stopID != rhs_storage._stopID {return false}
        if _storage._currentStatus != rhs_storage._currentStatus {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._congestionLevel != rhs_storage._congestionLevel {return false}
        if _storage._occupancyStatus != rhs_storage._occupancyStatus {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_VehiclePosition.VehicleStopStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INCOMING_AT"),
    1: .same(proto: "STOPPED_AT"),
    2: .same(proto: "IN_TRANSIT_TO"),
  ]
}

extension TransitRealtime_VehiclePosition.CongestionLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_CONGESTION_LEVEL"),
    1: .same(proto: "RUNNING_SMOOTHLY"),
    2: .same(proto: "STOP_AND_GO"),
    3: .same(proto: "CONGESTION"),
    4: .same(proto: "SEVERE_CONGESTION"),
  ]
}

extension TransitRealtime_VehiclePosition.OccupancyStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EMPTY"),
    1: .same(proto: "MANY_SEATS_AVAILABLE"),
    2: .same(proto: "FEW_SEATS_AVAILABLE"),
    3: .same(proto: "STANDING_ROOM_ONLY"),
    4: .same(proto: "CRUSHED_STANDING_ROOM_ONLY"),
    5: .same(proto: "FULL"),
    6: .same(proto: "NOT_ACCEPTING_PASSENGERS"),
  ]
}

extension TransitRealtime_Alert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Alert"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "active_period"),
    5: .standard(proto: "informed_entity"),
    6: .same(proto: "cause"),
    7: .same(proto: "effect"),
    8: .same(proto: "url"),
    10: .standard(proto: "header_text"),
    11: .standard(proto: "description_text"),
    12: .standard(proto: "tts_header_text"),
    13: .standard(proto: "tts_description_text"),
    14: .standard(proto: "severity_level"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.activePeriod) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.informedEntity) {return false}
    if let v = self._url, !v.isInitialized {return false}
    if let v = self._headerText, !v.isInitialized {return false}
    if let v = self._descriptionText, !v.isInitialized {return false}
    if let v = self._ttsHeaderText, !v.isInitialized {return false}
    if let v = self._ttsDescriptionText, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.activePeriod) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.informedEntity) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._cause) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._effect) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._headerText) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._descriptionText) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._ttsHeaderText) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._ttsDescriptionText) }()
      case 14: try { try decoder.decodeSingularEnumField(value: &self._severityLevel) }()
      case 1000..<2000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_Alert.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.activePeriod.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.activePeriod, fieldNumber: 1)
    }
    if !self.informedEntity.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.informedEntity, fieldNumber: 5)
    }
    try { if let v = self._cause {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._effect {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._headerText {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._descriptionText {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._ttsHeaderText {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._ttsDescriptionText {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._severityLevel {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 14)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 2000)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransitRealtime_Alert, rhs: TransitRealtime_Alert) -> Bool {
    if lhs.activePeriod != rhs.activePeriod {return false}
    if lhs.informedEntity != rhs.informedEntity {return false}
    if lhs._cause != rhs._cause {return false}
    if lhs._effect != rhs._effect {return false}
    if lhs._url != rhs._url {return false}
    if lhs._headerText != rhs._headerText {return false}
    if lhs._descriptionText != rhs._descriptionText {return false}
    if lhs._ttsHeaderText != rhs._ttsHeaderText {return false}
    if lhs._ttsDescriptionText != rhs._ttsDescriptionText {return false}
    if lhs._severityLevel != rhs._severityLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_Alert.Cause: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UNKNOWN_CAUSE"),
    2: .same(proto: "OTHER_CAUSE"),
    3: .same(proto: "TECHNICAL_PROBLEM"),
    4: .same(proto: "STRIKE"),
    5: .same(proto: "DEMONSTRATION"),
    6: .same(proto: "ACCIDENT"),
    7: .same(proto: "HOLIDAY"),
    8: .same(proto: "WEATHER"),
    9: .same(proto: "MAINTENANCE"),
    10: .same(proto: "CONSTRUCTION"),
    11: .same(proto: "POLICE_ACTIVITY"),
    12: .same(proto: "MEDICAL_EMERGENCY"),
  ]
}

extension TransitRealtime_Alert.Effect: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "NO_SERVICE"),
    2: .same(proto: "REDUCED_SERVICE"),
    3: .same(proto: "SIGNIFICANT_DELAYS"),
    4: .same(proto: "DETOUR"),
    5: .same(proto: "ADDITIONAL_SERVICE"),
    6: .same(proto: "MODIFIED_SERVICE"),
    7: .same(proto: "OTHER_EFFECT"),
    8: .same(proto: "UNKNOWN_EFFECT"),
    9: .same(proto: "STOP_MOVED"),
    10: .same(proto: "NO_EFFECT"),
    11: .same(proto: "ACCESSIBILITY_ISSUE"),
  ]
}

extension TransitRealtime_Alert.SeverityLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UNKNOWN_SEVERITY"),
    2: .same(proto: "INFO"),
    3: .same(proto: "WARNING"),
    4: .same(proto: "SEVERE"),
  ]
}

extension TransitRealtime_UpdateBundle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateBundle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "GTFSStaticBundle"),
    2: .standard(proto: "update_sequence"),
    4: .standard(proto: "cancelled_trip"),
  ]

  public var isInitialized: Bool {
    if self._gtfsstaticBundle == nil {return false}
    if self._updateSequence == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._gtfsstaticBundle) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._updateSequence) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.cancelledTrip) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._gtfsstaticBundle {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updateSequence {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.cancelledTrip.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cancelledTrip, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransitRealtime_UpdateBundle, rhs: TransitRealtime_UpdateBundle) -> Bool {
    if lhs._gtfsstaticBundle != rhs._gtfsstaticBundle {return false}
    if lhs._updateSequence != rhs._updateSequence {return false}
    if lhs.cancelledTrip != rhs.cancelledTrip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TransitRealtime_TimeRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimeRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._start) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._end) }()
      case 1000..<2000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TimeRange.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 2000)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransitRealtime_TimeRange, rhs: TransitRealtime_TimeRange) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Position"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
    3: .same(proto: "bearing"),
    4: .same(proto: "odometer"),
    5: .same(proto: "speed"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if self._latitude == nil {return false}
    if self._longitude == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._latitude) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._longitude) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._bearing) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._odometer) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._speed) }()
      case 1000..<2000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_Position.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._latitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._longitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bearing {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._odometer {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._speed {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 2000)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransitRealtime_Position, rhs: TransitRealtime_Position) -> Bool {
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs._bearing != rhs._bearing {return false}
    if lhs._odometer != rhs._odometer {return false}
    if lhs._speed != rhs._speed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TripDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TripDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trip_id"),
    5: .standard(proto: "route_id"),
    6: .standard(proto: "direction_id"),
    2: .standard(proto: "start_time"),
    3: .standard(proto: "start_date"),
    4: .standard(proto: "schedule_relationship"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._tripID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._startTime) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._startDate) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._scheduleRelationship) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._routeID) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._directionID) }()
      case 1000..<2000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TripDescriptor.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tripID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._startTime {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._startDate {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._scheduleRelationship {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._routeID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._directionID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 2000)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransitRealtime_TripDescriptor, rhs: TransitRealtime_TripDescriptor) -> Bool {
    if lhs._tripID != rhs._tripID {return false}
    if lhs._routeID != rhs._routeID {return false}
    if lhs._directionID != rhs._directionID {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._startDate != rhs._startDate {return false}
    if lhs._scheduleRelationship != rhs._scheduleRelationship {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TripDescriptor.ScheduleRelationship: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SCHEDULED"),
    1: .same(proto: "ADDED"),
    2: .same(proto: "UNSCHEDULED"),
    3: .same(proto: "CANCELED"),
    5: .same(proto: "REPLACEMENT"),
  ]
}

extension TransitRealtime_VehicleDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "label"),
    3: .standard(proto: "license_plate"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._licensePlate) }()
      case 1000..<2000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_VehicleDescriptor.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._licensePlate {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 2000)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransitRealtime_VehicleDescriptor, rhs: TransitRealtime_VehicleDescriptor) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._label != rhs._label {return false}
    if lhs._licensePlate != rhs._licensePlate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TfnswVehicleDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TfnswVehicleDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "air_conditioned"),
    2: .standard(proto: "wheelchair_accessible"),
    3: .standard(proto: "vehicle_model"),
    4: .standard(proto: "performing_prior_trip"),
    5: .standard(proto: "special_vehicle_attributes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._airConditioned) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._wheelchairAccessible) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._vehicleModel) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._performingPriorTrip) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._specialVehicleAttributes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._airConditioned {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._wheelchairAccessible {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._vehicleModel {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._performingPriorTrip {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._specialVehicleAttributes {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransitRealtime_TfnswVehicleDescriptor, rhs: TransitRealtime_TfnswVehicleDescriptor) -> Bool {
    if lhs._airConditioned != rhs._airConditioned {return false}
    if lhs._wheelchairAccessible != rhs._wheelchairAccessible {return false}
    if lhs._vehicleModel != rhs._vehicleModel {return false}
    if lhs._performingPriorTrip != rhs._performingPriorTrip {return false}
    if lhs._specialVehicleAttributes != rhs._specialVehicleAttributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TransitRealtime_CarriageDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CarriageDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "position_in_consist"),
    3: .standard(proto: "occupancy_status"),
    4: .standard(proto: "quiet_carriage"),
    5: .same(proto: "toilet"),
    6: .standard(proto: "luggage_rack"),
    7: .standard(proto: "departure_occupancy_status"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if self._positionInConsist == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._positionInConsist) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._occupancyStatus) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._quietCarriage) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._toilet) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._luggageRack) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._departureOccupancyStatus) }()
      case 1000..<2000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_CarriageDescriptor.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._positionInConsist {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._occupancyStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._quietCarriage {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._toilet {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._luggageRack {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._departureOccupancyStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 2000)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransitRealtime_CarriageDescriptor, rhs: TransitRealtime_CarriageDescriptor) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._positionInConsist != rhs._positionInConsist {return false}
    if lhs._occupancyStatus != rhs._occupancyStatus {return false}
    if lhs._quietCarriage != rhs._quietCarriage {return false}
    if lhs._toilet != rhs._toilet {return false}
    if lhs._luggageRack != rhs._luggageRack {return false}
    if lhs._departureOccupancyStatus != rhs._departureOccupancyStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_CarriageDescriptor.OccupancyStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EMPTY"),
    1: .same(proto: "MANY_SEATS_AVAILABLE"),
    2: .same(proto: "FEW_SEATS_AVAILABLE"),
    3: .same(proto: "STANDING_ROOM_ONLY"),
    4: .same(proto: "CRUSHED_STANDING_ROOM_ONLY"),
    5: .same(proto: "FULL"),
  ]
}

extension TransitRealtime_CarriageDescriptor.ToiletStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "NORMAL"),
    2: .same(proto: "ACCESSIBLE"),
  ]
}

extension TransitRealtime_EntitySelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntitySelector"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "agency_id"),
    2: .standard(proto: "route_id"),
    3: .standard(proto: "route_type"),
    4: .same(proto: "trip"),
    5: .standard(proto: "stop_id"),
    6: .standard(proto: "direction_id"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._trip, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._agencyID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._routeID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._routeType) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._trip) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._stopID) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._directionID) }()
      case 1000..<2000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_EntitySelector.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._agencyID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._routeID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._routeType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._trip {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._stopID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._directionID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 2000)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransitRealtime_EntitySelector, rhs: TransitRealtime_EntitySelector) -> Bool {
    if lhs._agencyID != rhs._agencyID {return false}
    if lhs._routeID != rhs._routeID {return false}
    if lhs._routeType != rhs._routeType {return false}
    if lhs._trip != rhs._trip {return false}
    if lhs._stopID != rhs._stopID {return false}
    if lhs._directionID != rhs._directionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TranslatedString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TranslatedString"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "translation"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.translation) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.translation) }()
      case 1000..<2000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TranslatedString.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.translation.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.translation, fieldNumber: 1)
    }
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 2000)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransitRealtime_TranslatedString, rhs: TransitRealtime_TranslatedString) -> Bool {
    if lhs.translation != rhs.translation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TranslatedString.Translation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TransitRealtime_TranslatedString.protoMessageName + ".Translation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "language"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if self._text == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._language) }()
      case 1000..<2000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TranslatedString.Translation.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._language {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 2000)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransitRealtime_TranslatedString.Translation, rhs: TransitRealtime_TranslatedString.Translation) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs._language != rhs._language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}
